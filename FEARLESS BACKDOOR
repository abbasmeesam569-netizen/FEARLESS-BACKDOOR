-- FEARLESS EXECUTER — Full rebuild (620x360) with top-bar drag, close/minimize, and working Backdoor Scanner
-- Paste into a local script (client) and run. Uses safe pcall for risky ops.

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer

local function createFEARLESSInterface()
    -- remove old GUI
    pcall(function()
        local core = game:GetService("CoreGui")
        local old = core:FindFirstChild("FEARLESS Executer")
        if old then old:Destroy() end
    end)

    -- screen gui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "FEARLESS Executer"
    screenGui.ResetOnSpawn = false
    pcall(function() screenGui.Parent = game:GetService("CoreGui") end)

    -- main frame
    local main = Instance.new("Frame")
    main.Name = "Main"
    main.Size = UDim2.new(0, 620, 0, 360)
    main.AnchorPoint = Vector2.new(0.5, 0.5)
    main.Position = UDim2.new(0.5, 0, 0.5, 0)
    main.BackgroundColor3 = Color3.fromRGB(28, 28, 28)
    main.BorderSizePixel = 0
    main.Parent = screenGui

    -- outer stroke
    local outerStroke = Instance.new("UIStroke", main)
    outerStroke.Color = Color3.fromRGB(200, 80, 90)
    outerStroke.Thickness = 3
    outerStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

    local bgGrad = Instance.new("UIGradient", main)
    bgGrad.Rotation = 90
    bgGrad.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(36,36,36)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(22,22,22))
    }

    -- top bar (drag area) with title + controls
    local topBar = Instance.new("Frame", main)
    topBar.Name = "TopBar"
    topBar.Size = UDim2.new(1, 0, 0, 36)
    topBar.Position = UDim2.new(0, 0, 0, 0)
    topBar.BackgroundTransparency = 0.15
    topBar.BorderSizePixel = 0

    local topTitle = Instance.new("TextLabel", topBar)
    topTitle.Name = "Title"
    topTitle.Size = UDim2.new(1, -86, 1, 0)
    topTitle.Position = UDim2.new(0, 12, 0, 0)
    topTitle.BackgroundTransparency = 1
    topTitle.Font = Enum.Font.SourceSansBold
    topTitle.TextSize = 18
    topTitle.TextXAlignment = Enum.TextXAlignment.Left
    topTitle.Text = "FEARLESS EXECUTER"
    topTitle.TextColor3 = Color3.fromRGB(240,240,240)

    -- minimize button
    local minimizeBtn = Instance.new("TextButton", topBar)
    minimizeBtn.Name = "Minimize"
    minimizeBtn.Size = UDim2.new(0, 34, 0, 22)
    minimizeBtn.Position = UDim2.new(1, -84, 0, 7)
    minimizeBtn.BackgroundTransparency = 0
    minimizeBtn.BackgroundColor3 = Color3.fromRGB(18,18,18)
    minimizeBtn.Font = Enum.Font.SourceSansBold
    minimizeBtn.TextSize = 18
    minimizeBtn.Text = "—"
    minimizeBtn.TextColor3 = Color3.fromRGB(220,220,220)
    minimizeBtn.AutoButtonColor = true
    minimizeBtn.BorderSizePixel = 0
    Instance.new("UICorner", minimizeBtn).CornerRadius = UDim.new(0,4)
    local minStroke = Instance.new("UIStroke", minimizeBtn) minStroke.Color = Color3.fromRGB(120,35,45) minStroke.Thickness = 1

    -- close button
    local closeBtn = Instance.new("TextButton", topBar)
    closeBtn.Name = "Close"
    closeBtn.Size = UDim2.new(0, 34, 0, 22)
    closeBtn.Position = UDim2.new(1, -44, 0, 7)
    closeBtn.BackgroundTransparency = 0
    closeBtn.BackgroundColor3 = Color3.fromRGB(18,18,18)
    closeBtn.Font = Enum.Font.SourceSansBold
    closeBtn.TextSize = 16
    closeBtn.Text = "✕"
    closeBtn.TextColor3 = Color3.fromRGB(230,230,230)
    closeBtn.AutoButtonColor = true
    closeBtn.BorderSizePixel = 0
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0,4)
    local closeStroke = Instance.new("UIStroke", closeBtn) closeStroke.Color = Color3.fromRGB(120,35,45) closeStroke.Thickness = 1

    -- executor area (big black box)
    local execFrame = Instance.new("Frame", main)
    execFrame.Name = "ExecutorBox"
    execFrame.Position = UDim2.new(0.02, 0, 0, 44)
    execFrame.Size = UDim2.new(0.66, 0, 0, 260)
    execFrame.BackgroundColor3 = Color3.fromRGB(0,0,0)
    execFrame.BorderSizePixel = 0
    Instance.new("UICorner", execFrame).CornerRadius = UDim.new(0,4)
    local execStroke = Instance.new("UIStroke", execFrame) execStroke.Color = Color3.fromRGB(100,30,40) execStroke.Thickness = 2

    local execText = Instance.new("TextBox", execFrame)
    execText.Name = "TextBox"
    execText.Size = UDim2.new(1, -12, 1, -12)
    execText.Position = UDim2.new(0, 6, 0, 6)
    execText.BackgroundTransparency = 0
    execText.BackgroundColor3 = Color3.fromRGB(0,0,0)
    execText.TextColor3 = Color3.fromRGB(230,230,230)
    execText.Font = Enum.Font.Code
    execText.TextSize = 16
    execText.MultiLine = true
    execText.ClearTextOnFocus = false
    execText.TextWrapped = false
    execText.PlaceholderText = "-- paste or write code here"

    -- right side results panel (for scanner output / logs)
    local resultsFrame = Instance.new("Frame", main)
    resultsFrame.Name = "ResultsFrame"
    resultsFrame.Position = UDim2.new(0.70, 0, 0, 44)
    resultsFrame.Size = UDim2.new(0.28, 0, 0, 260)
    resultsFrame.BackgroundColor3 = Color3.fromRGB(16,16,16)
    resultsFrame.BorderSizePixel = 0
    Instance.new("UICorner", resultsFrame).CornerRadius = UDim.new(0,4)
    local resStroke = Instance.new("UIStroke", resultsFrame) resStroke.Color = Color3.fromRGB(80,22,30) resStroke.Thickness = 1

    local resultsTitle = Instance.new("TextLabel", resultsFrame)
    resultsTitle.Size = UDim2.new(1, -8, 0, 20)
    resultsTitle.Position = UDim2.new(0, 4, 0, 6)
    resultsTitle.BackgroundTransparency = 1
    resultsTitle.Font = Enum.Font.SourceSansBold
    resultsTitle.TextSize = 14
    resultsTitle.Text = "Scanner Results"
    resultsTitle.TextColor3 = Color3.fromRGB(230,230,230)
    resultsTitle.TextXAlignment = Enum.TextXAlignment.Left

    local resultsBox = Instance.new("TextBox", resultsFrame)
    resultsBox.Name = "ResultsBox"
    resultsBox.Position = UDim2.new(0, 6, 0, 30)
    resultsBox.Size = UDim2.new(1, -12, 1, -36)
    resultsBox.BackgroundTransparency = 0
    resultsBox.BackgroundColor3 = Color3.fromRGB(12,12,12)
    resultsBox.TextColor3 = Color3.fromRGB(210,210,210)
    resultsBox.Font = Enum.Font.Code
    resultsBox.TextSize = 14
    resultsBox.MultiLine = true
    resultsBox.ClearTextOnFocus = false
    resultsBox.TextWrapped = true
    resultsBox.Text = "No scans yet."

    -- status line
    local status = Instance.new("TextLabel", main)
    status.Name = "Status"
    status.Position = UDim2.new(0.02, 0, 1, -30)
    status.Size = UDim2.new(0.66, 0, 0, 20)
    status.BackgroundTransparency = 1
    status.Font = Enum.Font.SourceSans
    status.TextSize = 14
    status.TextColor3 = Color3.fromRGB(200,200,200)
    status.Text = "Status: Idle"

    -- buttons row (bottom left)
    local executeBtn = Instance.new("TextButton", main)
    executeBtn.Name = "Execute"
    executeBtn.Size = UDim2.new(0, 170, 0, 44)
    executeBtn.Position = UDim2.new(0, 18, 1, -82)
    executeBtn.BackgroundColor3 = Color3.fromRGB(22,22,22)
    executeBtn.Font = Enum.Font.SourceSansBold
    executeBtn.TextSize = 20
    executeBtn.Text = "Execute"
    executeBtn.TextColor3 = Color3.fromRGB(240,240,240)
    Instance.new("UICorner", executeBtn).CornerRadius = UDim.new(0,6)
    Instance.new("UIStroke", executeBtn).Color = Color3.fromRGB(120,35,45)

    local clearBtn = Instance.new("TextButton", main)
    clearBtn.Name = "Clear"
    clearBtn.Size = UDim2.new(0, 120, 0, 44)
    clearBtn.Position = UDim2.new(0, 200, 1, -82)
    clearBtn.BackgroundColor3 = Color3.fromRGB(22,22,22)
    clearBtn.Font = Enum.Font.SourceSansBold
    clearBtn.TextSize = 18
    clearBtn.Text = "Clear"
    clearBtn.TextColor3 = Color3.fromRGB(240,240,240)
    Instance.new("UICorner", clearBtn).CornerRadius = UDim.new(0,6)
    Instance.new("UIStroke", clearBtn).Color = Color3.fromRGB(120,35,45)

    -- small right-side action buttons
    local smallW, smallH = 140, 36
    local offsetX = 350
    local gap = 8

    local function makeSmallBtn(name, text, idx)
        local btn = Instance.new("TextButton", main)
        btn.Name = name
        btn.Size = UDim2.new(0, smallW, 0, smallH)
        btn.Position = UDim2.new(0, offsetX + (smallW + gap) * (idx - 1), 1, -82)
        btn.BackgroundColor3 = Color3.fromRGB(16,16,16)
        btn.Font = Enum.Font.SourceSans
        btn.TextSize = 14
        btn.Text = text
        btn.TextColor3 = Color3.fromRGB(230,230,230)
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0,4)
        Instance.new("UIStroke", btn).Color = Color3.fromRGB(120,35,45)
        return btn
    end

    local resetBtn = makeSmallBtn("ResetCharacter", "Reset Character", 1)
    local bodyBtn = makeSmallBtn("BodyTypeSwitch", "Body Type Switch", 2)
    local backdoorBtn = makeSmallBtn("BackdoorScanner", "Backdoor Scanner", 3)

    -- expose references
    local ui = {
        ScreenGui = screenGui,
        Main = main,
        TopBar = topBar,
        Title = topTitle,
        ExecutorBox = execFrame,
        TextBox = execText,
        ResultsBox = resultsBox,
        Status = status,
        ExecuteButton = executeBtn,
        ClearButton = clearBtn,
        ResetCharacterButton = resetBtn,
        BodyTypeSwitchButton = bodyBtn,
        BackdoorScannerButton = backdoorBtn,
        MinimizeButton = minimizeBtn,
        CloseButton = closeBtn
    }

    -- Basic button behaviors
    clearBtn.MouseButton1Click:Connect(function()
        pcall(function() execText.Text = "" end)
        status.Text = "Status: Cleared editor"
    end)

    executeBtn.MouseButton1Click:Connect(function()
        local code = execText.Text or ""
        if code == "" then
            status.Text = "Status: Nothing to execute"
            return
        end
        status.Text = "Status: Executing..."
        local ok, func = pcall(loadstring, code)
        if not ok or type(func) ~= "function" then
            status.Text = "Status: Compile error"
            return
        end
        local runOk, runErr = pcall(func)
        if not runOk then
            status.Text = "Status: Exec error"
            warn("Execution error:", runErr)
        else
            status.Text = "Status: Exec success"
        end
    end)

    -- Reset/Body Buttons call handlers if provided in environment
    resetBtn.MouseButton1Click:Connect(function()
        status.Text = "Status: Resetting..."
        local ok,_ = pcall(function()
            if type(ResetCharacter) == "function" then return ResetCharacter() end
            if _G and type(_G.ResetCharacter) == "function" then return _G.ResetCharacter() end
        end)
        if not ok then status.Text = "Status: Reset failed or handler missing" else status.Text = "Status: Reset done" end
    end)

    bodyBtn.MouseButton1Click:Connect(function()
        status.Text = "Status: Switching body type..."
        local ok,_ = pcall(function()
            if type(BodyTypeSwitch) == "function" then return BodyTypeSwitch() end
            if _G and type(_G.BodyTypeSwitch) == "function" then return _G.BodyTypeSwitch() end
        end)
        if not ok then status.Text = "Status: Switch failed or handler missing" else status.Text = "Status: Switch done" end
    end)

    -- Close / Minimize
    local minimized = false
    minimizeBtn.MouseButton1Click:Connect(function()
        if minimized then
            -- restore
            main.Size = UDim2.new(0, 620, 0, 360)
            execFrame.Visible = true
            resultsFrame.Visible = true
            clearBtn.Visible = true
            executeBtn.Visible = true
            resetBtn.Visible = true
            bodyBtn.Visible = true
            backdoorBtn.Visible = true
            status.Visible = true
            minimized = false
        else
            -- minimize to top bar only
            main.Size = UDim2.new(0, 300, 0, 36)
            execFrame.Visible = false
            resultsFrame.Visible = false
            clearBtn.Visible = false
            executeBtn.Visible = false
            resetBtn.Visible = false
            bodyBtn.Visible = false
            backdoorBtn.Visible = false
            status.Visible = false
            minimized = true
        end
    end)

    closeBtn.MouseButton1Click:Connect(function()
        pcall(function() screenGui:Destroy() end)
    end)

    -- Backdoor Scanner implementation
    -- It scans:
    -- 1) the code inside the editor for suspicious patterns
    -- 2) global table _G for suspicious keys or functions
    -- 3) game descendants for RemoteEvent/RemoteFunction names that match suspicious patterns
    local suspiciousPatterns = {
        "remote", "backdoor", "admin", "steal", "exploit", "bypass", "sethidden", "setreadonly",
        "getconnections", "getsignal", "httpget", "http_request", "httpservice", "syn", "setclipboard",
        "fireserver", "invokeServer", "InvokeServer", "FireServer", "require%(", "loadstring%(", "load%(",
        "runstring", "getfenv", "setfenv", "kick", "ban", "delete", "destroy", "teleport", "spam"
    }

    local function scanTextForPatterns(text)
        local found = {}
        if not text or text == "" then return found end
        local low = text:lower()
        for _, pat in ipairs(suspiciousPatterns) do
            -- use plain find when possible; the patterns table uses simple substrings and some lua patterns
            local ok, sPat = pcall(function() return pat end)
            local startFound = nil
            if ok then
                -- attempt plain substring search first for faster checks
                if string.find(low, pat, 1, true) then
                    table.insert(found, ("Matched pattern: %q"):format(pat))
                else
                    -- fallback to pattern find (for patterns with special chars like %()
                    local ok2 = pcall(function()
                        if string.find(low, pat) then
                            table.insert(found, ("Matched pattern (pattern mode): %q"):format(pat))
                        end
                    end)
                    -- ignore errors in pattern matching
                end
            end
        end
        return found
    end

    local function scanGlobals()
        local results = {}
        pcall(function()
            for k, v in pairs(_G or {}) do
                local keyName = tostring(k):lower()
                for _, pat in ipairs(suspiciousPatterns) do
                    if string.find(keyName, pat, 1, true) then
                        table.insert(results, ("_G key suspicious: %s"):format(tostring(k)))
                        break
                    end
                end
                if type(v) == "function" then
                    local funcName = tostring(v):lower()
                    for _, pat in ipairs(suspiciousPatterns) do
                        if string.find(funcName, pat, 1, true) then
                            table.insert(results, ("_G function suspicious: %s"):format(tostring(k)))
                            break
                        end
                    end
                end
            end
        end)
        return results
    end

    local function scanRemotes()
        local found = {}
        pcall(function()
            for _, obj in ipairs(game:GetDescendants()) do
                if obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction") then
                    local nameLower = tostring(obj.Name):lower()
                    for _, pat in ipairs(suspiciousPatterns) do
                        if string.find(nameLower, pat, 1, true) then
                            table.insert(found, ("Remote matched: %s (class %s) at %s"):format(obj.Name, obj.ClassName, obj:GetFullName()))
                            break
                        end
                    end
                end
            end
        end)
        return found
    end

    -- A helper to produce a readable result string
    local function formatScanResults(resultsTable)
        if not resultsTable or #resultsTable == 0 then
            return "No suspicious items found."
        end
        local out = {}
        for i, v in ipairs(resultsTable) do
            table.insert(out, ("[%d] %s"):format(i, v))
        end
        return table.concat(out, "\n")
    end

    backdoorBtn.MouseButton1Click:Connect(function()
        status.Text = "Status: Scanning..."
        resultsBox.Text = "Scanning..."
        -- gather results
        local finalResults = {}

        -- 1) scan editor text
        local editor = ""
        pcall(function() editor = execText.Text or "" end)
        local editorFinds = scanTextForPatterns(editor)
        if #editorFinds > 0 then
            table.insert(finalResults, "== Suspicious code patterns found in editor ==")
            for _, v in ipairs(editorFinds) do table.insert(finalResults, v) end
        else
            table.insert(finalResults, "== Editor check: clean ==")
        end

        -- 2) scan _G
        local gFinds = scanGlobals()
        if #gFinds > 0 then
            table.insert(finalResults, "\n== Suspicious global entries (_G) ==")
            for _, v in ipairs(gFinds) do table.insert(finalResults, v) end
        else
            table.insert(finalResults, "\n== _G check: clean ==")
        end

        -- 3) scan remotes in game
        local remFinds = scanRemotes()
        if #remFinds > 0 then
            table.insert(finalResults, "\n== Suspicious Remotes found in game ==")
            for _, v in ipairs(remFinds) do table.insert(finalResults, v) end
        else
            table.insert(finalResults, "\n== Remotes check: no suspicious names found ==")
        end

        -- 4) optional quick heuristics: loaded modules or known exploit libs in global environment
        -- look for common exploit libs (syn, secure_load, etc)
        local heuristics = {}
        pcall(function()
            if rawget(_G, "syn") or rawget(_G, "Synapse") then table.insert(heuristics, "Exploit library object found in _G (syn/Synapse)") end
            if rawget(_G, "identifyexecutor") or rawget(_G, "identify_executor") then table.insert(heuristics, "Executor-identify function present in _G") end
        end)
        if #heuristics > 0 then
            table.insert(finalResults, "\n== Heuristics ==")
            for _, v in ipairs(heuristics) do table.insert(finalResults, v) end
        end

        -- produce final text
        local outText = table.concat(finalResults, "\n")
        resultsBox.Text = outText
        status.Text = "Status: Scan complete"
    end)

    -- Make the top bar draggable (only topBar)
    local dragging, dragStart, startPos, dragInput
    topBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = main.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    topBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            main.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)

    return ui
end

-- create UI
local ok, uiOrErr = pcall(createFEARLESSInterface)
if not ok then
    warn("Failed to create FEARLESS Executer:", uiOrErr)
end
